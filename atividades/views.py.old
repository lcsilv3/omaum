import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.core.paginator import Paginator
from django.contrib.auth.decorators import login_required
from django.urls import reverse
from django.http import HttpResponse
import importlib

# Importar a função utilitária centralizada
from core.utils import get_model_dynamically, get_form_dynamically

# Set up logger
logger = logging.getLogger(__name__)

print(
    "ARQUIVO VIEWS.PY CARREGADO:",
    importlib.import_module("django.conf").settings.BASE_DIR,
)


def get_return_url(request, default_url):
    """Obtém a URL de retorno do request ou usa o valor padrão."""
    return_url = request.GET.get("return_url", "")
    # Verificação básica de segurança
    if not return_url or not return_url.startswith("/"):
        return default_url
    return return_url


def get_form_class(form_name):
    """Importa dinamicamente uma classe de formulário para evitar importações circulares."""
    return get_form_dynamically("atividades", form_name)


def get_model_class(model_name, module_name="atividades"):
    """Importa dinamicamente uma classe de modelo para evitar importações circulares."""
    return get_model_dynamically(module_name, model_name)


@login_required
def listar_atividades(request):
    """Página inicial do módulo de atividades."""
    return render(request, "atividades/listar_atividades.html")


@login_required
def listar_atividades_academicas(request):
    """Lista todas as atividades acadêmicas."""
    AtividadeAcademica = get_model_class("AtividadeAcademica")
    
    # Adicionar suporte para busca e filtros
    query = request.GET.get('q', '')
    turma_id = request.GET.get('turma', '')
    
    atividades = AtividadeAcademica.objects.all().order_by('-data_inicio')
    
    # Aplicar filtros se fornecidos
    if query:
        atividades = atividades.filter(
            nome__icontains=query
        )
    
    if turma_id:
        atividades = atividades.filter(turmas__id=turma_id)
    
    # Paginação
    paginator = Paginator(atividades, 10)  # 10 itens por página
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Armazenar a URL atual na sessão para uso posterior
    request.session["last_academicas_list_url"] = request.get_full_path()

    # Obter lista de turmas para o filtro
    Turma = get_model_class("Turma", "turmas")
    turmas = Turma.objects.filter(status="A")

    return render(
        request,
        "atividades/listar_atividades_academicas.html",
        {
            "atividades": page_obj,
            "page_obj": page_obj,
            "query": query,
            "turma_selecionada": turma_id,
            "turmas": turmas,
            "return_url": request.path,  # Armazena URL atual para retorno
        },
    )


@login_required
def listar_atividades_ritualisticas(request):
    """Lista todas as atividades ritualísticas."""
    AtividadeRitualistica = get_model_class("AtividadeRitualistica")
    
    # Adicionar suporte para busca e filtros
    query = request.GET.get('q', '')
    turma_id = request.GET.get('turma', '')
    data_inicio = request.GET.get('data_inicio', '')
    data_fim = request.GET.get('data_fim', '')
    
    atividades = AtividadeRitualistica.objects.all().order_by('-data')
    
    # Aplicar filtros se fornecidos
    if query:
        atividades = atividades.filter(
            nome__icontains=query
        )
    
    if turma_id:
        atividades = atividades.filter(turma_id=turma_id)
        
    if data_inicio:
        atividades = atividades.filter(data__gte=data_inicio)
        
    if data_fim:
        atividades = atividades.filter(data__lte=data_fim)
    
    # Paginação
    paginator = Paginator(atividades, 10)  # 10 itens por página
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Armazenar a URL atual na sessão para uso posterior
    request.session["last_ritualisticas_list_url"] = request.get_full_path()

    # Salvar URL referenciadora, exceto se vier do próprio formulário de atividade ritualística
    referer = request.META.get("HTTP_REFERER", "")
    if referer and not any(
        x in referer
        for x in [
            "criar_atividade_ritualistica",
            "editar_atividade_ritualistica",
        ]
    ):
        request.session["atividade_ritualistica_referer"] = referer

    # Usar a URL referenciadora armazenada ou a página inicial como fallback
    previous_url = request.session.get("atividade_ritualistica_referer", "/")
    
    # Obter lista de turmas para o filtro
    Turma = get_model_class("Turma", "turmas")
    turmas = Turma.objects.filter(status="A")

    return render(
        request,
        "atividades/listar_atividades_ritualisticas.html",
        {
            "atividades": page_obj,
            "page_obj": page_obj,
            "query": query,
            "turma_selecionada": turma_id,
            "data_inicio": data_inicio,
            "data_fim": data_fim,
            "turmas": turmas,
            "previous_url": previous_url,
        },
    )


@login_required
def criar_atividade_academica(request):
    """Função para criar uma nova atividade acadêmica."""
    AtividadeAcademicaForm = get_form_class("AtividadeAcademicaForm")
    return_url = request.GET.get(
        "return_url", reverse("atividades:listar_atividades_academicas")
    )

    if request.method == "POST":
        form = AtividadeAcademicaForm(request.POST)
        if form.is_valid():
            try:
                atividade = form.save(commit=False)
                
                # Verificar se é para todas as turmas
                todas_turmas = form.cleaned_data.get('todas_turmas', False)
                
                # Salvar a atividade primeiro
                atividade.save()
                
                if todas_turmas:
                    # Obter todas as turmas ativas
                    Turma = get_model_class("Turma", "turmas")
                    turmas_ativas = Turma.objects.filter(status="A")
                    
                    # Adicionar todas as turmas ativas
                    atividade.turmas.set(turmas_ativas)
                    
                    # Log para depuração
                    logger.info(f"Atividade {atividade.id} associada a {turmas_ativas.count()} turmas ativas")
                else:
                    # Usar as turmas selecionadas no formulário
                    form.save_m2m()  # Salvar relações ManyToMany
                    
                    # Log para depuração
                    logger.info(f"Atividade {atividade.id} associada a {atividade.turmas.count()} turmas selecionadas")
                
                messages.success(
                    request, "Atividade acadêmica criada com sucesso."
                )
                return redirect(return_url)
            except Exception as e:
                logger.error(f"Erro ao criar atividade acadêmica: {str(e)}", exc_info=True)
                messages.error(request, f"Erro ao criar atividade acadêmica: {str(e)}")
        else:
            messages.error(request, "Corrija os erros no formulário.")
    else:
        form = AtividadeAcademicaForm()

    return render(
        request,
        "atividades/formulario_atividade_academica.html",
        {"form": form, "return_url": return_url},
    )


@login_required
def editar_atividade_academica(request, pk):
    """Função para editar uma atividade acadêmica existente."""
    AtividadeAcademica = get_model_class("AtividadeAcademica")
    AtividadeAcademicaForm = get_form_class("AtividadeAcademicaForm")
    atividade = get_object_or_404(AtividadeAcademica, pk=pk)
    return_url = request.GET.get(
        "return_url", reverse("atividades:listar_atividades_academicas")
    )

    if request.method == "POST":
        try:
            form = AtividadeAcademicaForm(request.POST, instance=atividade)
            if form.is_valid():
                atividade = form.save(commit=False)
                
                # Verificar se é para todas as turmas
                todas_turmas = form.cleaned_data.get('todas_turmas', False)
                
                # Salvar a atividade primeiro
                atividade.save()
                
                if todas_turmas:
                    # Obter todas as turmas ativas
                    Turma = get_model_class("Turma", "turmas")
                    turmas_ativas = Turma.objects.filter(status="A")
                    
                    # Adicionar todas as turmas ativas
                    atividade.turmas.set(turmas_ativas)
                    
                    # Log para depuração
                    logger.info(f"Atividade {atividade.id} atualizada com {turmas_ativas.count()} turmas ativas")
                else:
                    # Usar as turmas selecionadas no formulário
                    form.save_m2m()  # Salvar relações ManyToMany
                    
                    # Log para depuração
                    logger.info(f"Atividade {atividade.id} atualizada com {atividade.turmas.count()} turmas selecionadas")
                
                messages.success(
                    request, "Atividade acadêmica atualizada com sucesso."
                )
                return redirect(return_url)
            else:
                messages.error(request, "Corrija os erros no formulário.")
        except Exception as e:
            logger.error(f"Erro ao atualizar atividade acadêmica: {str(e)}", exc_info=True)
            messages.error(
                request,
                f"Erro ao processar formulário de atividade acadêmica: {str(e)}",
            )
    else:
        # Verificar se a atividade está associada a todas as turmas ativas
        Turma = get_model_class("Turma", "turmas")
        turmas_ativas = Turma.objects.filter(status="A")
        todas_turmas_selecionadas = (
            atividade.turmas.count() == turmas_ativas.count() and
            all(turma in atividade.turmas.all() for turma in turmas_ativas)
        )
        
        # Inicializar o formulário com o valor correto para todas_turmas
        form = AtividadeAcademicaForm(
            instance=atividade, 
            initial={'todas_turmas': todas_turmas_selecionadas}
        )

    return render(
        request,
        "atividades/formulario_atividade_academica.html",
        {"form": form, "atividade": atividade, "return_url": return_url},
    )


@login_required
def excluir_atividade_academica(request, pk):
    """Função para excluir uma atividade acadêmica."""
    AtividadeAcademica = get_model_class("AtividadeAcademica")
    atividade = get_object_or_404(AtividadeAcademica, pk=pk)
    return_url = request.GET.get(
        "return_url", reverse("atividades:listar_atividades_academicas")
    )

    if request.method == "POST":
        try:
            nome_atividade = atividade.nome  # Guardar o nome para a mensagem
            atividade.delete()
            messages.success(
                request, f"Atividade acadêmica '{nome_atividade}' excluída com sucesso."
            )
            return redirect(return_url)
        except Exception as e:
            logger.error(f"Erro ao excluir atividade acadêmica: {str(e)}", exc_info=True)
            messages.error(
                request, f"Erro ao excluir atividade acadêmica: {str(e)}"
            )
            return redirect("atividades:listar_atividades_academicas")

    return render(
        request,
        "atividades/confirmar_exclusao_academica.html",
        {"atividade": atividade, "return_url": return_url},
    )


@login_required
def confirmar_exclusao_academica(request, pk):
    """Função para confirmar a exclusão de uma atividade acadêmica."""
    AtividadeAcademica = get_model_class("AtividadeAcademica")
    atividade = get_object_or_404(AtividadeAcademica, pk=pk)
    return_url = request.GET.get(
        "return_url", reverse("atividades:listar_atividades_academicas")
    )

    if request.method == "POST":
        try:
            nome_atividade = atividade.nome  # Guardar o nome para a mensagem
            atividade.delete()
            messages.success(
                request, f"Atividade acadêmica '{nome_atividade}' excluída com sucesso."
            )
            return redirect(return_url)
        except Exception as e:
            logger.error(f"Erro ao excluir atividade acadêmica: {str(e)}", exc_info=True)
            messages.error(
                request, f"Erro ao excluir atividade acadêmica: {str(e)}"
            )
            return redirect("atividades:detalhar_atividade_academica", pk=pk)

    return render(
        request,
        "atividades/confirmar_exclusao_academica.html",
        {"atividade": atividade, "return_url": return_url},
    )


@login_required
def detalhar_atividade_academica(request, pk):
    """Função para mostrar detalhes de uma atividade acadêmica."""
    AtividadeAcademica = get_model_class("AtividadeAcademica")
    atividade = get_object_or_404(AtividadeAcademica, pk=pk)
    return_url = request.GET.get(
        "return_url", reverse("atividades:listar_atividades_academicas")
    )
    
    # Calcular estatísticas sobre as turmas
    total_turmas = atividade.turmas.count()
    turmas_ativas = atividade.turmas.filter(status="A").count()
    
    # Verificar se está associada a todas as turmas ativas do sistema
    Turma = get_model_class("Turma", "turmas")
    total_turmas_ativas_sistema = Turma.objects.filter(status="A").count()
    todas_turmas_ativas = (turmas_ativas == total_turmas_ativas_sistema)

    return render(
        request,
        "atividades/detalhar_atividade_academica.html",
        {
            "atividade": atividade, 
            "return_url": return_url,
            "total_turmas": total_turmas,
            "turmas_ativas": turmas_ativas,
            "todas_turmas_ativas": todas_turmas_ativas
        },
    )


@login_required
def criar_atividade_ritualistica(request):
    """Função para criar uma nova atividade ritualística."""
    AtividadeRitualisticaForm = get_form_class("AtividadeRitualisticaForm")
    return_url = request.GET.get(
        "return_url", reverse("atividades:listar_atividades_ritualisticas")
    )

    if request.method == "POST":
        try:
            form = AtividadeRitualisticaForm(request.POST)
            if form.is_valid():
                atividade = form.save(commit=False)
                atividade.save()

                # Processar o campo todos_alunos se existir
                if hasattr(form, "cleaned_data") and form.cleaned_data.get(
                    "todos_alunos"
                ):
                    # Obter todos os alunos da turma e adicioná-los à atividade
                    Aluno = get_model_class(
                        "Aluno", module_name="alunos"
                    )
                    alunos_da_turma = Aluno.objects.filter(
                        turmas=atividade.turma
                    )
                    for aluno in alunos_da_turma:
                        atividade.participantes.add(aluno)
                else:
                    # Salvar apenas os participantes selecionados no formulário
                    form.save_m2m()

                messages.success(
                    request, "Atividade ritualística criada com sucesso."
                )
                return redirect(return_url)
            else:
                messages.error(request, "Corrija os erros no formulário.")
        except Exception as e:
            logger.error(f"Erro ao criar atividade ritualística: {str(e)}", exc_info=True)
            messages.error(
                request,
                f"Erro ao processar formulário de atividade ritualística: {str(e)}",
            )
    else:
        form = AtividadeRitualisticaForm()

    return render(
        request,
        "atividades/criar_atividade_ritualistica.html",
        {"form": form, "return_url": return_url},
    )


@login_required
def editar_atividade_ritualistica(request, pk):
    """Função para editar uma atividade ritualística existente."""
    AtividadeRitualistica = get_model_class("AtividadeRitualistica")
    AtividadeRitualisticaForm = get_form_class("AtividadeRitualisticaForm")
    atividade = get_object_or_404(AtividadeRitualistica, pk=pk)
    return_url = request.GET.get(
        "return_url", reverse("atividades:listar_atividades_ritualisticas")
    )

    if request.method == "POST":
        try:
            form = AtividadeRitualisticaForm(request.POST, instance=atividade)
            if form.is_valid():
                atividade = form.save(commit=False)
                atividade.save()

                # Processar o campo todos_alunos se existir
                if hasattr(form, "cleaned_data") and form.cleaned_data.get(
                    "todos_alunos"
                ):
                    # Limpar participantes existentes
                    atividade.participantes.clear()
                    # Obter todos os alunos da turma e adicioná-los à atividade
                    Aluno = get_model_class(
                        "Aluno", module_name="alunos"
                    )
                    alunos_da_turma = Aluno.objects.filter(
                        turmas=atividade.turma
                    )
                    for aluno in alunos_da_turma:
                        atividade.participantes.add(aluno)
                else:
                    # Salvar apenas os participantes selecionados no formulário
                    form.save_m2m()

                messages.success(
                    request, "Atividade ritualística atualizada com sucesso."
                )
                return redirect(return_url)
            else:
                messages.error(request, "Corrija os erros no formulário.")
        except Exception as e:
            logger.error(f"Erro ao atualizar atividade ritualística: {str(e)}", exc_info=True)
            messages.error(
                request,
                f"Erro ao processar formulário de atividade ritualística: {str(e)}",
            )
    else:
        form = AtividadeRitualisticaForm(instance=atividade)

    return render(
        request,
        "atividades/editar_atividade_ritualistica.html",
        {"form": form, "atividade": atividade, "return_url": return_url},
    )


@login_required
def excluir_atividade_ritualistica(request, pk):
    """Função para excluir uma atividade ritualística."""
    AtividadeRitualistica = get_model_class("AtividadeRitualistica")
    atividade = get_object_or_404(AtividadeRitualistica, pk=pk)
    return_url = request.GET.get(
        "return_url", reverse("atividades:listar_atividades_ritualisticas")
    )

    if request.method == "POST":
        try:
            nome_atividade = atividade.nome  # Guardar o nome para a mensagem
            atividade.delete()
            messages.success(
                request, f"Atividade ritualística '{nome_atividade}' excluída com sucesso."
            )
            return redirect(return_url)
        except Exception as e:
            logger.error(f"Erro ao excluir atividade ritualística: {str(e)}", exc_info=True)
            messages.error(
                request, f"Erro ao excluir atividade ritualística: {str(e)}"
            )
            return redirect("atividades:listar_atividades_ritualisticas")

    return render(
        request,
        "atividades/confirmar_exclusao_ritualistica.html",
        {"atividade": atividade, "return_url": return_url},
    )


@login_required
def confirmar_exclusao_ritualistica(request, pk):
    """Função para confirmar a exclusão de uma atividade ritualística."""
    AtividadeRitualistica = get
@login_required
def confirmar_exclusao_ritualistica(request, pk):
    """Função para confirmar a exclusão de uma atividade ritualística."""
    AtividadeRitualistica = get_model_class("AtividadeRitualistica")
    atividade = get_object_or_404(AtividadeRitualistica, pk=pk)
    return_url = request.GET.get(
        "return_url", reverse("atividades:listar_atividades_ritualisticas")
    )

    if request.method == "POST":
        try:
            nome_atividade = atividade.nome  # Guardar o nome para a mensagem
            atividade.delete()
            messages.success(
                request, f"Atividade ritualística '{nome_atividade}' excluída com sucesso."
            )
            return redirect(return_url)
        except Exception as e:
            logger.error(f"Erro ao excluir atividade ritualística: {str(e)}", exc_info=True)
            messages.error(
                request, f"Erro ao excluir atividade ritualística: {str(e)}"
            )
            return redirect(
                "atividades:detalhar_atividade_ritualistica", pk=pk
            )

    return render(
        request,
        "atividades/confirmar_exclusao_ritualistica.html",
        {"atividade": atividade, "return_url": return_url},
    )


@login_required
def detalhar_atividade_ritualistica(request, pk):
    """Função para mostrar detalhes de uma atividade ritualística."""
    AtividadeRitualistica = get_model_class("AtividadeRitualistica")
    atividade = get_object_or_404(AtividadeRitualistica, pk=pk)
    return_url = request.GET.get(
        "return_url", reverse("atividades:listar_atividades_ritualisticas")
    )

    # Calcular o total de participantes para exibição
    total_participantes = atividade.participantes.count()
    
    # Verificar se todos os alunos da turma estão participando
    Aluno = get_model_class("Aluno", module_name="alunos")
    total_alunos_turma = Aluno.objects.filter(turmas=atividade.turma).count()
    todos_alunos_participando = (total_participantes == total_alunos_turma) and (total_alunos_turma > 0)

    return render(
        request,
        "atividades/detalhar_atividade_ritualistica.html",
        {
            "atividade": atividade, 
            "return_url": return_url,
            "total_participantes": total_participantes,
            "total_alunos_turma": total_alunos_turma,
            "todos_alunos_participando": todos_alunos_participando
        },
    )


@login_required
def relatorio_atividades(request):
    """Gera um relatório de atividades com base nos filtros aplicados."""
    AtividadeAcademica = get_model_class("AtividadeAcademica")
    AtividadeRitualistica = get_model_class("AtividadeRitualistica")
    
    # Obter parâmetros de filtro
    tipo = request.GET.get('tipo', 'todas')
    status = request.GET.get('status', '')
    data_inicio = request.GET.get('data_inicio', '')
    data_fim = request.GET.get('data_fim', '')
    
    # Filtrar atividades acadêmicas
    atividades_academicas = AtividadeAcademica.objects.all()
    
    if status:
        atividades_academicas = atividades_academicas.filter(status=status)
    
    if data_inicio:
        atividades_academicas = atividades_academicas.filter(data_inicio__gte=data_inicio)
    
    if data_fim:
        atividades_academicas = atividades_academicas.filter(data_inicio__lte=data_fim)
    
    # Filtrar atividades ritualísticas
    atividades_ritualisticas = AtividadeRitualistica.objects.all()
    
    if data_inicio:
        atividades_ritualisticas = atividades_ritualisticas.filter(data__gte=data_inicio)
    
    if data_fim:
        atividades_ritualisticas = atividades_ritualisticas.filter(data__lte=data_fim)
    
    # Aplicar filtro por tipo
    if tipo == 'academicas':
        atividades_ritualisticas = AtividadeRitualistica.objects.none()
    elif tipo == 'ritualisticas':
        atividades_academicas = AtividadeAcademica.objects.none()
    
    # Calcular totais
    total_academicas = atividades_academicas.count()
    total_ritualisticas = atividades_ritualisticas.count()
    total_atividades = total_academicas + total_ritualisticas
    
    return render(
        request,
        "atividades/relatorio_atividades.html",
        {
            "atividades_academicas": atividades_academicas,
            "atividades_ritualisticas": atividades_ritualisticas,
            "total_academicas": total_academicas,
            "total_ritualisticas": total_ritualisticas,
            "total_atividades": total_atividades,
            "tipo": tipo,
            "status": status,
            "data_inicio": data_inicio,
            "data_fim": data_fim,
        },
    )


@login_required
def exportar_atividades(request, formato):
    """Exporta as atividades filtradas para o formato especificado."""
    # Obter os mesmos filtros que no relatório
    tipo = request.GET.get('tipo', 'todas')
    status = request.GET.get('status', '')
    data_inicio = request.GET.get('data_inicio', '')
    data_fim = request.GET.get('data_fim', '')
    
    # Obter atividades filtradas (mesmo código do relatório)
    AtividadeAcademica = get_model_class("AtividadeAcademica")
    AtividadeRitualistica = get_model_class("AtividadeRitualistica")
    
    atividades_academicas = AtividadeAcademica.objects.all()
    if status:
        atividades_academicas = atividades_academicas.filter(status=status)
    if data_inicio:
        atividades_academicas = atividades_academicas.filter(data_inicio__gte=data_inicio)
    if data_fim:
        atividades_academicas = atividades_academicas.filter(data_inicio__lte=data_fim)
    
    atividades_ritualisticas = AtividadeRitualistica.objects.all()
    if data_inicio:
        atividades_ritualisticas = atividades_ritualisticas.filter(data__gte=data_inicio)
    if data_fim:
        atividades_ritualisticas = atividades_ritualisticas.filter(data__lte=data_fim)
    
    if tipo == 'academicas':
        atividades_ritualisticas = AtividadeRitualistica.objects.none()
    elif tipo == 'ritualisticas':
        atividades_academicas = AtividadeAcademica.objects.none()
    
    # Exportar para o formato solicitado
    if formato == 'csv':
        return exportar_atividades_csv(atividades_academicas, atividades_ritualisticas)
    elif formato == 'excel':
        return exportar_atividades_excel(atividades_academicas, atividades_ritualisticas)
    elif formato == 'pdf':
        return exportar_atividades_pdf(atividades_academicas, atividades_ritualisticas)
    else:
        messages.error(request, f"Formato de exportação '{formato}' não suportado.")
        return redirect('atividades:relatorio_atividades')

def exportar_atividades_csv(atividades_academicas, atividades_ritualisticas):
    """Exporta as atividades para CSV."""
    import csv
    from django.http import HttpResponse
    
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="atividades.csv"'
    
    writer = csv.writer(response)
    
    # Cabeçalho para atividades acadêmicas
    writer.writerow(['Tipo', 'Nome', 'Descrição', 'Data de Início', 'Data de Término', 
                     'Responsável', 'Local', 'Status', 'Tipo de Atividade'])
    
    # Dados das atividades acadêmicas
    for atividade in atividades_academicas:
        writer.writerow([
            'Acadêmica',
            atividade.nome,
            atividade.descricao or '',
            atividade.data_inicio.strftime('%d/%m/%Y'),
            atividade.data_fim.strftime('%d/%m/%Y') if atividade.data_fim else '',
            atividade.responsavel or '',
            atividade.local or '',
            atividade.get_status_display(),
            atividade.get_tipo_atividade_display(),
        ])
    
    # Dados das atividades ritualísticas
    for atividade in atividades_ritualisticas:
        writer.writerow([
            'Ritualística',
            atividade.nome,
            atividade.descricao or '',
            atividade.data.strftime('%d/%m/%Y'),
            '',  # Não tem data_fim
            '',  # Não tem responsável
            atividade.local,
            '',  # Não tem status
            '',  # Não tem tipo_atividade
        ])
    
    return response

def exportar_atividades_excel(atividades_academicas, atividades_ritualisticas):
    """Exporta as atividades para Excel."""
    # Implementação básica usando pandas
    try:
        import pandas as pd
        from django.http import HttpResponse
        from io import BytesIO
        
        # Criar DataFrames para cada tipo de atividade
        dados_academicas = []
        for atividade in atividades_academicas:
            dados_academicas.append({
                'Tipo': 'Acadêmica',
                'Nome': atividade.nome,
                'Descrição': atividade.descricao or '',
                'Data de Início': atividade.data_inicio,
                'Data de Término': atividade.data_fim,
                'Responsável': atividade.responsavel or '',
                'Local': atividade.local or '',
                'Status': atividade.get_status_display(),
                'Tipo de Atividade': atividade.get_tipo_atividade_display(),
            })
        
        dados_ritualisticas = []
        for atividade in atividades_ritualisticas:
            dados_ritualisticas.append({
                'Tipo': 'Ritualística',
                'Nome': atividade.nome,
                'Descrição': atividade.descricao or '',
                'Data': atividade.data,
                'Horário': f"{atividade.hora_inicio} - {atividade.hora_fim}",
                'Local': atividade.local,
                'Turma': atividade.turma.nome,
                'Participantes': atividade.participantes.count(),
            })
        
        # Criar arquivo Excel com múltiplas abas
        output = BytesIO()
        with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
            if dados_academicas:
                df_academicas = pd.DataFrame(dados_academicas)
                df_academicas.to_excel(writer, sheet_name='Atividades Acadêmicas', index=False)
            
            if dados_ritualisticas:
                df_ritualisticas = pd.DataFrame(dados_ritualisticas)
                df_ritualisticas.to_excel(writer, sheet_name='Atividades Ritualísticas', index=False)
        
        # Configurar resposta HTTP
        output.seek(0)
        response = HttpResponse(output.read(), content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
        response['Content-Disposition'] = 'attachment; filename="atividades.xlsx"'
        
        return response
    except ImportError:
        # Fallback para CSV se pandas não estiver disponível
        return exportar_atividades_csv(atividades_academicas, atividades_ritualisticas)

def exportar_atividades_pdf(atividades_academicas, atividades_ritualisticas):
    """Exporta as atividades para PDF."""
    # Implementação básica usando reportlab
    try:
        from reportlab.lib import colors
        from reportlab.lib.pagesizes import letter, landscape
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
        from reportlab.lib.styles import getSampleStyleSheet
        from django.http import HttpResponse
        import io
        
        # Configurar buffer e documento
        buffer = io.BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=landscape(letter))
        elements = []
        
        # Estilos
        styles = getSampleStyleSheet()
        title_style = styles['Heading1']
        subtitle_style = styles['Heading2']
        
        # Título
        elements.append(Paragraph("Relatório de Atividades", title_style))
        elements.append(Spacer(1, 12))
        
        # Atividades Acadêmicas
        if atividades_academicas:
            elements.append(Paragraph("Atividades Acadêmicas", subtitle_style))
            elements.append(Spacer(1, 6))
            
            # Dados para a tabela
            data = [['Nome', 'Tipo', 'Data de Início', 'Status', 'Responsável']]
            
            for atividade in atividades_academicas:
                data.append([
                    atividade.nome,
                    atividade.get_tipo_atividade_display(),
                    atividade.data_inicio.strftime('%d/%m/%Y'),
                    atividade.get_status_display(),
                    atividade.responsavel or 'Não informado',
                ])
            
            # Criar tabela
            table = Table(data)
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ]))
            
            elements.append(table)
            elements.append(Spacer(1, 12))
        
        # Atividades Ritualísticas
        if atividades_ritualisticas:
            elements.append(Paragraph("Atividades Ritualísticas", subtitle_style))
            elements.append(Spacer(1, 6))
            
            # Dados para a tabela
            data = [['Nome', 'Data', 'Horário', 'Local', 'Turma', 'Participantes']]
            
            for atividade in atividades_ritualisticas:
                data.append([
                    atividade.nome,
                    atividade.data.strftime('%d/%m/%Y'),
                    f"{atividade.hora_inicio} - {atividade.hora_fim}",
                    atividade.local,
                    atividade.turma.nome,
                    str(atividade.participantes.count()),
                ])
            
            # Criar tabela
            table = Table(data)
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ]))
            
            elements.append(table)
        
        # Gerar PDF
        doc.build(elements)
        
        # Configurar resposta HTTP
        buffer.seek(0)
        response = HttpResponse(buffer.read(), content_type='application/pdf')
        response['Content-Disposition'] = 'attachment; filename="atividades.pdf"'
        
        return response
    except ImportError:
        # Fallback para CSV se reportlab não estiver disponível
        return exportar_atividades_csv(atividades_academicas, atividades_ritualisticas)
@login_required
def calendario_atividades(request):
    """Exibe o calendário de atividades."""
    # Obter todas as turmas para o filtro
    Turma = get_model_dynamically("turmas", "Turma")
    turmas = Turma.objects.filter(status='A')  # Apenas turmas ativas
    
    return render(
        request,
        "atividades/calendario_atividades.html",
        {
            "turmas": turmas,
        },
    )

@login_required
def api_eventos_calendario(request):
    """API para fornecer eventos para o calendário."""
    from django.http import JsonResponse
    
    # Obter parâmetros
    start_date = request.GET.get('start', '')
    end_date = request.GET.get('end', '')
    tipo_filtro = request.GET.get('tipo', 'todas')
    turma_filtro = request.GET.get('turma', 'todas')
    mostrar_concluidas = request.GET.get('concluidas', '1') == '1'
    
    # Obter modelos
    AtividadeAcademica = get_model_class("AtividadeAcademica")
    AtividadeRitualistica = get_model_class("AtividadeRitualistica")
    
    eventos = []
    
    # Adicionar atividades acadêmicas
    if tipo_filtro in ['todas', 'academicas']:
        atividades_academicas = AtividadeAcademica.objects.all()
        
        # Aplicar filtro de data
        if start_date:
            atividades_academicas = atividades_academicas.filter(data_inicio__gte=start_date)
        if end_date:
            atividades_academicas = atividades_academicas.filter(data_inicio__lte=end_date)
        
        # Aplicar filtro de turma
        if turma_filtro != 'todas':
            atividades_academicas = atividades_academicas.filter(turma_id=turma_filtro)
        
        # Aplicar filtro de status concluído
        if not mostrar_concluidas:
            atividades_academicas = atividades_academicas.exclude(status='concluida')
        
        # Converter para formato de evento do FullCalendar
        for atividade in atividades_academicas:
            evento = {
                'id': atividade.id,
                'title': atividade.nome,
                'start': atividade.data_inicio.isoformat(),
                'end': atividade.data_fim.isoformat() if atividade.data_fim else None,
                'allDay': True,  # Por padrão, eventos de dia inteiro
                'tipo': 'academica',
                'status': atividade.status,
                'description': atividade.descricao or '',
            }
            eventos.append(evento)
    
    # Adicionar atividades ritualísticas
    if tipo_filtro in ['todas', 'ritualisticas']:
        atividades_ritualisticas = AtividadeRitualistica.objects.all()
        
        # Aplicar filtro de data
        if start_date:
            atividades_ritualisticas = atividades_ritualisticas.filter(data__gte=start_date)
        if end_date:
            atividades_ritualisticas = atividades_ritualisticas.filter(data__lte=end_date)
        
        # Aplicar filtro de turma
        if turma_filtro != 'todas':
            atividades_ritualisticas = atividades_ritualisticas.filter(turma_id=turma_filtro)
        
        # Converter para formato de evento do FullCalendar
        for atividade in atividades_ritualisticas:
            # Combinar data e hora para criar datetime completo
            from datetime import datetime, time
            data = atividade.data
            
            # Converter hora_inicio e hora_fim para objetos time
            hora_inicio = atividade.hora_inicio
            hora_fim = atividade.hora_fim
            
            # Criar datetime para início e fim
            start_datetime = datetime.combine(data, hora_inicio)
            end_datetime = datetime.combine(data, hora_fim)
            
            evento = {
                'id': atividade.id,
                'title': atividade.nome,
                'start': start_datetime.isoformat(),
                'end': end_datetime.isoformat(),
                'allDay': False,  # Eventos ritualísticos têm horário específico
                'tipo': 'ritualistica',
                'description': atividade.descricao or '',
            }
            eventos.append(evento)
    
    return JsonResponse(eventos, safe=False)

@login_required
def api_detalhe_evento(request, evento_id):
    """API para fornecer detalhes de um evento específico."""
    from django.http import JsonResponse
    
    tipo = request.GET.get('tipo', '')
    
    try:
        if tipo == 'academica':
            AtividadeAcademica = get_model_class("AtividadeAcademica")
            atividade = get_object_or_404(AtividadeAcademica, id=evento_id)
            
            # Formatar dados para resposta JSON
            evento = {
                'nome': atividade.nome,
                'descricao': atividade.descricao,
                'data_inicio': atividade.data_inicio.strftime('%d/%m/%Y'),
                'data_fim': atividade.data_fim.strftime('%d/%m/%Y') if atividade.data_fim else None,
                'responsavel': atividade.responsavel,
                'local': atividade.local,
                'tipo': atividade.tipo_atividade,
                'tipo_display': atividade.get_tipo_atividade_display(),
                'status': atividade.status,
                'status_display': atividade.get_status_display(),
                'turma': atividade.turma.nome if atividade.turma else 'Sem turma',
            }
            
            return JsonResponse({'success': True, 'evento': evento})
        
        elif tipo == 'ritualistica':
            AtividadeRitualistica = get_model_class("AtividadeRitualistica")
            atividade = get_object_or_404(AtividadeRitualistica, id=evento_id)
            
            # Formatar dados para resposta JSON
            evento = {
                'nome': atividade.nome,
                'descricao': atividade.descricao,
                'data': atividade.data.strftime('%d/%m/%Y'),
                'hora_inicio': atividade.hora_inicio.strftime('%H:%M'),
                'hora_fim': atividade.hora_fim.strftime('%H:%M'),
                'local': atividade.local,
                'turma': atividade.turma.nome if atividade.turma else 'Sem turma',
                'total_participantes': atividade.participantes.count(),
            }
            
            return JsonResponse({'success': True, 'evento': evento})
        
        else:
            return JsonResponse({'success': False, 'error': 'Tipo de evento inválido'}, status=400)
    
    except Exception as e:
        logger.error(f"Erro ao obter detalhes do evento: {str(e)}")
        return JsonResponse({'success': False, 'error': str(e)}, status=500)
@login_required
def dashboard_atividades(request):
    """Exibe o dashboard de atividades com estatísticas e gráficos."""
    import json
    from datetime import datetime, timedelta
    from django.db.models import Count
    from django.db.models.functions import TruncMonth
    
    # Obter modelos
    AtividadeAcademica = get_model_class("AtividadeAcademica")
    AtividadeRitualistica = get_model_class("AtividadeRitualistica")
    
    # Estatísticas gerais
    total_academicas = AtividadeAcademica.objects.count()
    total_ritualisticas = AtividadeRitualistica.objects.count()
    total_atividades = total_academicas + total_ritualisticas
    
    # Estatísticas de status (apenas para atividades acadêmicas)
    status_counts = dict(AtividadeAcademica.objects.values('status').annotate(count=Count('status')).values_list('status', 'count'))
    total_agendadas = status_counts.get('agendada', 0)
    
    # Atividades por mês (últimos 6 meses)
    hoje = datetime.now().date()
    seis_meses_atras = hoje - timedelta(days=180)
    
    # Preparar dados para o gráfico de atividades por mês
    academicas_por_mes = AtividadeAcademica.objects.filter(
        data_inicio__gte=seis_meses_atras
    ).annotate(
        mes=TruncMonth('data_inicio')
    ).values('mes').annotate(
        count=Count('id')
    ).order_by('mes')
    
    ritualisticas_por_mes = AtividadeRitualistica.objects.filter(
        data__gte=seis_meses_atras
    ).annotate(
        mes=TruncMonth('data')
    ).values('mes').annotate(
        count=Count('id')
    ).order_by('mes')
    
    # Converter para dicionários para facilitar o acesso
    academicas_dict = {item['mes'].strftime('%Y-%m'): item['count'] for item in academicas_por_mes}
    ritualisticas_dict = {item['mes'].strftime('%Y-%m'): item['count'] for item in ritualisticas_por_mes}
    
    # Gerar lista de meses (últimos 6 meses)
    meses = []
    academicas_counts = []
    ritualisticas_counts = []
    
    for i in range(5, -1, -1):
        mes_data = hoje.replace(day=1) - timedelta(days=i*30)
        mes_str = mes_data.strftime('%Y-%m')
        mes_nome = mes_data.strftime('%b/%Y')
        
        meses.append(mes_nome)
        academicas_counts.append(academicas_dict.get(mes_str, 0))
        ritualisticas_counts.append(ritualisticas_dict.get(mes_str, 0))
    
    # Próximas atividades
    proximas_academicas = AtividadeAcademica.objects.filter(
        data_inicio__gte=hoje
    ).exclude(
        status='cancelada'
    ).order_by('data_inicio')[:5]
    
    proximas_ritualisticas = AtividadeRitualistica.objects.filter(
        data__gte=hoje
    ).order_by('data', 'hora_inicio')[:5]
    
    # Adicionar tipo para facilitar o template
    for atividade in proximas_academicas:
        atividade.tipo = 'academica'
    
    for atividade in proximas_ritualisticas:
        atividade.tipo = 'ritualistica'
    
    # Combinar e ordenar por data
    proximas_atividades = sorted(
        list(proximas_academicas) + list(proximas_ritualisticas),
        key=lambda x: x.data_inicio if hasattr(x, 'data_inicio') else x.data
    )[:5]
    
    # Atividades recentes
    recentes_academicas = AtividadeAcademica.objects.filter(
        data_inicio__lt=hoje
    ).order_by('-data_inicio')[:5]
    
    recentes_ritualisticas = AtividadeRitualistica.objects.filter(
        data__lt=hoje
    ).order_by('-data')[:5]
    
    # Adicionar tipo para facilitar o template
    for atividade in recentes_academicas:
        atividade.tipo = 'academica'
    
    for atividade in recentes_ritualisticas:
        atividade.tipo = 'ritualistica'
    
    # Combinar e ordenar por data (decrescente)
    atividades_recentes = sorted(
        list(recentes_academicas) + list(recentes_ritualisticas),
        key=lambda x: x.data_inicio if hasattr(x, 'data_inicio') else x.data,
        reverse=True
    )[:5]
    
    return render(
        request,
        "atividades/dashboard_atividades.html",
        {
            "total_atividades": total_atividades,
            "total_academicas": total_academicas,
            "total_ritualisticas": total_ritualisticas,
            "total_agendadas": total_agendadas,
            "meses": meses,
            "academicas_counts": academicas_counts,
            "ritualisticas_counts": ritualisticas_counts,
            "proximas_atividades": proximas_atividades,
            "atividades_recentes": atividades_recentes,
        },
    )
@login_required
def copiar_atividade_academica(request, id):
    """Cria uma cópia de uma atividade acadêmica existente."""
    AtividadeAcademica = get_model_class("AtividadeAcademica")
    AtividadeAcademicaForm = get_form_class("AtividadeAcademicaForm")
    
    # Obter atividade original
    atividade_original = get_object_or_404(AtividadeAcademica, id=id)
    
    if request.method == "POST":
        # Criar formulário com dados do POST
        form = AtividadeAcademicaForm(request.POST)
        
        if form.is_valid():
            # Salvar nova atividade
            nova_atividade = form.save()
            
            # Verificar se deve copiar frequências
            copiar_frequencias = request.POST.get('copiar_frequencias') == 'on'
            
            if copiar_frequencias:
                try:
                    # Importar modelo de Frequencia
                    Frequencia = get_model_dynamically("frequencias", "Frequencia")
                    
                    # Obter frequências da atividade original
                    frequencias_originais = Frequencia.objects.filter(atividade=atividade_original)
                    
                    # Criar novas frequências
                    for freq in frequencias_originais:
                        Frequencia.objects.create(
                            aluno=freq.aluno,
                            atividade=nova_atividade,
                            data=nova_atividade.data_inicio,  # Usar a nova data
                            presente=False,  # Inicialmente todos ausentes
                            justificativa=None
                        )
                    
                    messages.success(
                        request, 
                        f"Atividade copiada com sucesso! {frequencias_originais.count()} registros de frequência foram copiados."
                    )
                except Exception as e:
                    logger.error(f"Erro ao copiar frequências: {str(e)}")
                    messages.warning(
                        request, 
                        f"Atividade copiada, mas ocorreu um erro ao copiar as frequências: {str(e)}"
                    )
            else:
                messages.success(request, "Atividade copiada com sucesso!")
            
            return redirect("atividades:detalhar_atividade_academica", pk=nova_atividade.id)
        else:
            messages.error(request, "Corrija os erros no formulário.")
    else:
        # Pré-preencher formulário com dados da atividade original
        initial_data = {
            'nome': f"Cópia de {atividade_original.nome}",
            'descricao': atividade_original.descricao,
            'tipo_atividade': atividade_original.tipo_atividade,
            'responsavel': atividade_original.responsavel,
            'local': atividade_original.local,
            'turma': atividade_original.turma,
            'status': 'agendada',  # Sempre começa como agendada
        }
        form = AtividadeAcademicaForm(initial=initial_data)
    
    return render(
        request,
        "atividades/copiar_atividade_academica.html",
        {
            "form": form,
            "atividade_original": atividade_original,
        },
    )

@login_required
def copiar_atividade_ritualistica(request, id):
    """Cria uma cópia de uma atividade ritualística existente."""
    AtividadeRitualistica = get_model_class("AtividadeRitualistica")
    AtividadeRitualisticaForm = get_form_class("AtividadeRitualisticaForm")
    
    # Obter atividade original
    atividade_original = get_object_or_404(AtividadeRitualistica, id=id)
    
    if request.method == "POST":
        # Criar formulário com dados do POST
        form = AtividadeRitualisticaForm(request.POST)
        
        if form.is_valid():
            # Salvar nova atividade sem os participantes
            nova_atividade = form.save(commit=False)
            nova_atividade.save()
            
            # Verificar se deve copiar participantes
            copiar_participantes = request.POST.get('copiar_participantes') == 'on'
            
            if copiar_participantes:
                # Copiar participantes da atividade original
                for participante in atividade_original.participantes.all():
                    nova_atividade.participantes.add(participante)
                
                messages.success(
                    request, 
                    f"Atividade copiada com sucesso! {atividade_original.participantes.count()} participantes foram copiados."
                )
            else:
                # Salvar apenas os participantes selecionados no formulário
                form.save_m2m()
                messages.success(request, "Atividade copiada com sucesso!")
            
            return redirect("atividades:detalhar_atividade_ritualistica", pk=nova_atividade.id)
        else:
            messages.error(request, "Corrija os erros no formulário.")
    else:
        # Pré-preencher formulário com dados da atividade original
        initial_data = {
            'nome': f"Cópia de {atividade_original.nome}",
            'descricao': atividade_original.descricao,
            'data': atividade_original.data,
            'hora_inicio': atividade_original.hora_inicio,
            'hora_fim': atividade_original.hora_fim,
            'local': atividade_original.local,
            'turma': atividade_original.turma,
        }
        form = AtividadeRitualisticaForm(initial=initial_data)
    
    context = {
        "form": form,
        "atividade_original": atividade_original,
    }
    
    return render(request, "atividades/copiar_atividade_ritualistica.html", context)
